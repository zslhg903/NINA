<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="ASCOM.DriverAccess" #>
<#@ import namespace="ASCOM.DriverAccess" #>
<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="$(TargetPath)" #>
<# Type[] types = new[] {
        typeof(Focuser),
        typeof(Camera),
        typeof(Dome),
        typeof(CoverCalibrator),
        typeof(Rotator),
        typeof(SafetyMonitor),
        typeof(Telescope),
        typeof(ObservingConditions),
        typeof(Switch),
        typeof(FilterWheel)
    };
    string[] baseProperties = new[] {
        "Connected",
        "Description",
        "DriverInfo",
        "DriverVersion",
        "InterfaceVersion",
        "Name",
        "SupportedActions"
    };
    string[] baseMethods = new[] {
        "SetupDialog",
        "Action",
        "CommandBlind",
        "CommandBool",
        "CommandString"
    };
#>
using System;
using ASCOM.DriverAccess;

// Auto Generated by "AscomDeviceFacades.tt"
namespace NINA.Equipment.ASCOMFacades {
    public interface IAscomDeviceFacade<T> : IDisposable where T : AscomDriver {
        T Proxied { get; set; }
        System.Boolean Connected { get; set; }
        System.String Description { get; }
        System.String DriverInfo { get; }
        System.String DriverVersion { get; }
        System.Int16 InterfaceVersion { get; }
        System.String Name { get; }
        System.Collections.ArrayList SupportedActions { get; }
        void SetupDialog();
        System.String Action(System.String ActionName, System.String ActionParameter);
        void CommandBlind(System.String Command, System.Boolean Raw);
        System.Boolean CommandBool(System.String Command, System.Boolean Raw);
        System.String CommandString(System.String Command, System.Boolean Raw);
    }

<# foreach (var type in types) { 
    var interfaceTypeName = $"I{type.Name}Facade";
    var proxyTypeName = $"{type.Name}FacadeProxy";
#>
    public interface <#= interfaceTypeName #> : IAscomDeviceFacade<<#= type.Name #>> {
    <# 
        var allProperties = type.GetProperties(System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public);
        var allMethods = type.GetMethods(System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public).Where(m => !m.IsSpecialName).ToList();
        foreach (var property in allProperties) {
            var propertyReturnTypeName = property.PropertyType.FullName;
            var propertyName = property.Name;
            var isBaseProperty = baseProperties.Contains(propertyName);
            if (isBaseProperty) {
                continue;
            }

            var hasGetter = property.CanRead;
            var hasSetter = property.CanWrite;
    #>
    <#= propertyReturnTypeName #> <#= propertyName #> {<# if (hasGetter) { #> get;<# } if (hasSetter) { #> set;<# } #> }
    <#  
        }

        foreach (var method in allMethods) {
            var methodFromObject = method.DeclaringType == typeof(Object);
            var methodName = method.Name;
            // This is a hack. I couldn't figure out how to dynamically determine whether this came from a parent interface
            var methodFromDisposable = methodName == "Dispose";
            if (methodFromObject || methodFromDisposable) {
                continue;
            }
            var isBaseMethod = baseMethods.Contains(methodName);
            if (isBaseMethod) {
                continue;
            }

            var methodReturnTypeName = (method.ReturnType == typeof(void)) ? "void" : method.ReturnType.FullName;
            var methodParameters = method.GetParameters();
            var argumentListString = string.Join(", ", methodParameters.Select(p => $"{p.ParameterType.FullName} {p.Name}"));
    #>
    <#= methodReturnTypeName #> <#= methodName #>(<#= argumentListString #>);
    <#
    }
    #>
}

    public class <#= proxyTypeName #> : <#= interfaceTypeName #> {
        private <#= type.Name #> proxied;

        public <#= type.Name #> Proxied { 
            get => proxied; 
            set {
                if (proxied != null) {
                    throw new Exception("Proxied already set");
                }
                proxied = value;
            }
        }
    <# 
        foreach (var property in allProperties) {
            var propertyReturnTypeName = property.PropertyType.FullName;
            var propertyName = property.Name;
            var hasGetter = property.CanRead;
            var hasSetter = property.CanWrite;
    #>
    public <#= propertyReturnTypeName #> <#= propertyName #> {<# if (hasGetter) { #> get => proxied.<#= propertyName #>;<# } if (hasSetter) { #> set => proxied.<#= propertyName #> = value;<# } #> }
    <#
        }

        foreach (var method in allMethods) {
            var methodFromObject = method.DeclaringType == typeof(Object);
            if (methodFromObject && !method.IsVirtual) {
                continue;
            }

            var methodName = method.Name;
            var isVoid = method.ReturnType == typeof(void);
            var methodReturnTypeName = isVoid ? "void" : method.ReturnType.FullName;
            var methodQualifier = methodFromObject ? "override " : "";
            var methodParameters = method.GetParameters();
            var argumentListString = string.Join(", ", methodParameters.Select(p => $"{p.ParameterType.FullName} {p.Name}"));
            var argumentNameListString = string.Join(", ", methodParameters.Select(p => p.Name));
            var invokeMethod = $"proxied.{methodName}({argumentNameListString});";
            if (!isVoid) {
                invokeMethod = "return " + invokeMethod;
            }
    #>
    public <#= methodQualifier #><#= methodReturnTypeName #> <#= methodName #>(<#= argumentListString #>) {
            <#= invokeMethod #>
        }
    <#
    }
    #>
}
<#
    }
#>
}